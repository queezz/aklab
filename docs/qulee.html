<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>aklab.qulee API documentation</title>
<meta name="description" content="&#34;Qulee&#34; (pronounced as &#34;KLEE&#34;), is ULVAC&#39;s latest model for residual gas analysis …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aklab.qulee</code></h1>
</header>
<section id="section-intro">
<p>"Qulee" (pronounced as "KLEE"), is ULVAC's latest model for residual gas analysis. </p>
<p>Tools to work with Qulee mass spectrometer outputs (CSV) and maybe later with Qulee software?
Created 2021/06/11 by queezz</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
&#34;Qulee&#34; (pronounced as &#34;KLEE&#34;), is ULVAC&#39;s latest model for residual gas analysis. 

Tools to work with Qulee mass spectrometer outputs (CSV) and maybe later with Qulee software?
Created 2021/06/11 by queezz
&#34;&#34;&#34;
from aklab.constants import *


class QMS:
    &#34;&#34;&#34;Read Qulee QMS CSV file, generate pandas.DataFrame, plot data.
    
    Parameters
    ----------
    datapath: string
            path to converted to `csv` format Qulee QMS data.
    &#34;&#34;&#34;

    def __init__(self, datapath):
        &#34;&#34;&#34; &#34;&#34;&#34;
        self.data = None
        self.path = datapath
        self.qms_file_parser()
        self.load_data()
        self.generate_colors()

    def qms_file_parser(self):
        &#34;&#34;&#34; &#34; Given filepath to ULVAC&#39;s Qulee BGM QMS file, converted to *.csv,
        Parses the header, extracts column names, QMS settings, and line number where data starts
        &#34;&#34;&#34;
        import codecs
        import datetime

        channels = []
        mlist = []
        params = dict([])
        with codecs.open(self.path, &#34;r&#34;, &#34;shift_jisx0213&#34;) as f:
            for index, line in enumerate(f):
                string = line.strip()
                # get masslist
                if string.startswith(&#39;&#34;測定質量数 &#39;):
                    masslist = string.split(&#39;&#34;&#39;)[2].split(&#34;,&#34;)
                    mlist = []
                    for m in masslist:
                        if m != &#34;&#34; and m != &#34;--&#34;:
                            mlist.append(int(m))
                if string.startswith(&#39;&#34;測定スピード&#39;):
                    channels.append(string)
                if string.startswith(&#39;&#34;SEM 電圧&#39;):
                    params[&#34;sem&#34;] = string.split(&#34;,&#34;)[1]

                if string.startswith(&#39;&#34;選択 FIL&#39;):
                    params[&#34;filament&#34;] = string.split(&#34;,&#34;)[1][1:-1].strip()
                if string.startswith(&#39;&#34;選択 SEM / FC&#39;):
                    params[&#34;semfil&#34;] = string.split(&#34;,&#34;)[1][1:-1].strip()
                if string.startswith(&#39;&#34;測定開始日時 &#39;):
                    params[&#34;start&#34;] = string.split(&#34;,&#34;)[1].strip()
                    self.start = datetime.datetime.strptime(params[&#34;start&#34;], &#34;%Y/%m/%d %H:%M:%S&#34;)
                if string.startswith(&#39;&#34;測定終了日時 &#39;):
                    params[&#34;end&#34;] = string.split(&#34;,&#34;)[1].strip()
                    self.end = datetime.datetime.strptime(params[&#34;end&#34;], &#34;%Y/%m/%d %H:%M:%S&#34;)
                if string.startswith(&#39;&#34;レシピ名称  &#39;):
                    try:
                        params[&#34;recipe&#34;] = str(string.split(&#34;,&#34;)[1][1:-1]).strip()
                    except NameError:
                        params[&#34;recipe&#34;] = str(string.split(&#34;,&#34;)[1][1:-1]).strip()
                if string.startswith(&#39;&#34;イオン化電圧 &#39;):
                    params[&#34;ionization&#34;] = string.split(&#34;,&#34;)[1].strip()
                if string.startswith(&#39;&#34;測定スピード   &#39;):
                    params[&#34;mass_sampling&#34;] = string.split(&#34;,&#34;)[1].strip()

                if string.startswith(&#34;1&#34;):
                    break
            chName = [&#34;No&#34;, &#34;Time&#34;, &#34;Trigger&#34;, &#34;analog2&#34;, &#34;qmsTP&#34;]
            for m in mlist:
                chName.append(&#34;m%d&#34; % m)

            self.colnames = chName
            self.skiprows = index
            self.stats = params
            self.masslist = [int(i[1:]) for i in self.colnames if i.startswith(&#34;m&#34;)]

    def load_data(self):
        &#34;&#34;&#34;Generates DataFrame from qms data with proper datetime column for time
        &#34;&#34;&#34;
        import pandas as pd
        from pandas import read_csv

        qmsdata = read_csv(
            self.path,
            skiprows=self.skiprows,
            delimiter=&#34;,&#34;,
            names=self.colnames,
            usecols=self.colnames,
            na_values=[&#34;-------&#34;, &#34;-&#34;],
            encoding=&#34;shift_jisx0213&#34;,
        )

        qmsdata.insert(0, &#34;tsec&#34;, t2sa(qmsdata[&#34;Time&#34;].values))
        timesec = pd.to_timedelta(qmsdata[&#34;tsec&#34;], unit=&#34;s&#34;) + self.start
        qmsdata.insert(0, &#34;date&#34;, timesec)

        self.data = qmsdata

    def generate_colors(self):
        &#34;&#34;&#34; Generate colors based on masslist&#34;&#34;&#34;
        import matplotlib.pylab as plt
        import numpy as np

        color = plt.cm.hsv(np.linspace(0.1, 0.9, len(self.masslist)))
        clr = {i: j for i, j in zip(self.masslist, color)}
        clr[2] = &#34;#ff421c&#34;
        clr[3] = &#34;#ffa305&#34;
        clr[4] = &#34;#6fff1c&#34;
        self.clr = clr

    def slice(self, delta):
        &#34;&#34;&#34; Slice DataFrame by datetime interval

        Parameters
        ----------
        delta: list
            list of datetime.dateme objects for the start and the end of an interval

        Returns
        -------
        data: pandas.DataFrame
            sliced qms dataframe
        &#34;&#34;&#34;
        a = delta[0].strftime(&#34;%Y%m%d%H%M%S&#34;)
        b = delta[1].strftime(&#34;%Y%m%d%H%M%S&#34;)
        return self.data.query(f&#34;{a} &lt; date &lt; {b}&#34;)

    def plot(self, **kws):
        &#34;&#34;&#34;plot time traces
        
        Parameters
        ----------
        masslist: list
            Specify list of masses to plot. Plots all by default.
        fro: datetime
            starting time, self.start by default.
        to: datetime
            ending time, self.end by default
        ylim: list or tuple 
            axis ylims
        gridalpha: float
             transparancy of the grid lines
        figsize: tuple
            figure size, (8,6) by default
        rasterized: bool
            rasterized option for matplotlib
        colors: list
            list of colors for color cycle
        bbox_to_anchor: list or tuple
            bbox_to_anchor argument for matplotlib legend
        &#34;&#34;&#34;
        import matplotlib.pylab as plt
        from matplotlib.ticker import AutoMinorLocator

        fro = kws.get(&#34;fro&#34;, self.start)
        tto = kws.get(&#34;tto&#34;, self.end)

        a = fro.strftime(&#34;%Y%m%d%H%M%S&#34;)
        b = tto.strftime(&#34;%Y%m%d%H%M%S&#34;)
        df = self.data.query(f&#34;{a} &lt; date &lt; {b}&#34;)

        figsize = kws.get(&#34;figsize&#34;, (8, 6))

        fig = plt.figure(figsize=figsize, facecolor=&#34;w&#34;)
        ax = plt.gca()

        masslist = kws.get(&#34;masslist&#34;, self.masslist)
        rasterized = kws.get(&#34;rasterized&#34;, False)
        clrs = kws.get(&#34;colors&#34;, self.clr)

        [plt.plot(df[&#34;date&#34;], df[f&#34;m{i}&#34;], label=f&#34;m{i}&#34;, rasterized=rasterized, c=clrs[i]) for i in masslist]

        ax.set_xlabel(&#34;time&#34;)
        ax.set_ylabel(&#34;QMS Current, A&#34;)
        plt.xticks(rotation=25, ha=&#34;right&#34;)
        ylims = kws.get(&#34;ylim&#34;, False)
        if ylims:
            ax.set_ylim(ylims)

        txt = (
            f&#34;{self.stats[&#39;start&#39;].split()[0]} {self.stats[&#39;filament&#39;]} {self.stats[&#39;semfil&#39;]} &#34;
            + f&#34;{self.stats[&#39;sem&#39;]} {self.stats[&#39;recipe&#39;]} {self.stats[&#39;mass_sampling&#39;]} s/a.m.e&#34;
        )
        ax.text(-0.15, 1.05, txt, transform=ax.transAxes)

        gridalpha = kws.get(&#34;gridalpha&#34;, [0.1, 0.3])
        customgrid(ax, gridalpha=gridalpha)
        customticks(ax)
        ax.set_yscale(&#34;log&#34;)

        axt = ax.twinx()
        trigger = self.data[&#34;Trigger&#34;].values
        axt.plot(df[&#34;date&#34;], df[&#34;Trigger&#34;] / df[&#34;Trigger&#34;].max(), &#34;r&#34;)
        axt.set_ylim(0, 20)
        axt.axes.yaxis.set_ticks([])

        bbox_to_anchor = kws.get(&#34;bbox_to_anchor&#34;, [1, 1])
        ax.legend(loc=1, bbox_to_anchor=bbox_to_anchor)


def t2s(t):
    &#34;&#34;&#34;
    Converts QMS timing into seconds.
    &#34;&#34;&#34;
    import datetime, time

    ms = t.split(&#34;.&#34;)[1]
    hh = int(t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[0])
    mm = t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[1]
    ss = t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[2]
    hoffset = 0
    if int(t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[0]) &gt; 23:
        hoffset = hh // 24
        tt = &#34;0%d:%s:%s&#34; % (hh - hoffset * 24, mm, ss)
    else:
        tt = &#34;0%d:%s:%s&#34; % (hh, mm, ss)
    x = time.strptime(tt, &#34;0%H:%M:%S&#34;)
    return (
        datetime.timedelta(hours=hoffset * 24 + x.tm_hour, minutes=x.tm_min, seconds=x.tm_sec).total_seconds()
        + float(ms) * 1e-3
    )


def t2sa(ta):
    &#34;&#34;&#34;
    convert an array of strings of the Qulee format: &#39;000:00:00.625&#39; to time in seconds.
    &#39;000:00:00.625&#39; -&gt; &#39;hhh:mm:ss.ms&#39;
    &#34;&#34;&#34;
    import numpy as np

    return np.array([t2s(tt) for tt in ta])


def customgrid(ax, **kws):
    # Setup grid
    gridalpha = kws.get(&#34;gridalpha&#34;, [0.1, 0.3])
    ax.grid(which=&#34;minor&#34;, linestyle=&#34;-&#34;, alpha=gridalpha[0])
    ax.grid(which=&#34;major&#34;, linestyle=&#34;-&#34;, alpha=gridalpha[1])


def customticks(ax):
    from matplotlib.ticker import LogLocator, AutoMinorLocator

    # Setup ticks
    xys = [ax.xaxis, ax.yaxis]
    [a.set_minor_locator(AutoMinorLocator()) for a in xys]
    ls = [7, 4]
    ws = [1, 0.8]
    [
        [a.set_tick_params(width=j, length=i, which=k) for i, j, k in zip(ls, ws, [&#34;major&#34;, &#34;minor&#34;])]
        for a in xys
    ]


def tocsv(filename, **kws):
    &#34;&#34;&#34; Convert native binary into csv with Quelee software installed.
    &#34;&#34;&#34;
    import platform, sys, subprocess, os, time

    if not platform.system() == &#34;Darwin&#34;:
        import win32api, win32con, win32com.client  # mouse control

        shell = win32com.client.Dispatch(&#34;WScript.Shell&#34;)  # this is to make a kay press

    try:
        retcode = subprocess.call(&#34;start &#34; + filename, shell=True)
        if retcode &lt; 0:
            print(&#34;Child was terminated by signal&#34;, retcode, file=sys.stderr)
        else:
            print(&#34;Child returned&#34;, file=sys.stderr)
    except OSError as e:
        print(&#34;Execution failed:&#34;, e, file=sys.stderr)

    &#34;&#34;&#34;Convert data to *.csv using this macro&#34;&#34;&#34;
    size = os.stat(os.path.join(filename)).st_size
    if size / 1.8e6 &lt; 1:
        tsave = 1
    else:
        tsave = int(size / 2e6) + 1
    &#34;&#34;&#34; windows script to convert *.qst to *.csv&#34;&#34;&#34;
    tt = 0.2
    time.sleep(tt)
    shell.SendKeys(&#34;{ESC}&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ENTER}&#34;)
    time.sleep(tt + 1)
    shell.SendKeys(&#34;%ft&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ENTER}&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;y&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ESC}&#34;)
    time.sleep(tt + tsave)
    shell.SendKeys(&#34;%fc&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ESC}&#34;)
    &#34;&#34;&#34; close Qulee&#34;&#34;&#34;
    shell.SendKeys(&#34;%{F4}&#34;)


def generate_colors(masslist, **kws):
    &#34;&#34;&#34; Generate colors based on masslist
    
    Parameters
    ----------
    masslist: list
            list of masses to be plotted
    cmap: matplotlib colormap for color cycle
    
    Returns
    -------
    clr: list
        list of colors
    &#34;&#34;&#34;
    import matplotlib.pylab as plt, numpy as np

    cmap = kws.get(&#34;cmap&#34;, plt.cm.twilight)

    color = cmap(np.linspace(0.1, 0.9, len(masslist)))
    clr = {i: j for i, j in zip(masslist, color)}
    clr[2] = &#34;#ff421c&#34;
    clr[3] = &#34;#ffa305&#34;
    clr[4] = &#34;#6fff1c&#34;
    clr[18] = &#34;#05ffde&#34;
    clr[28] = &#34;#5983ff&#34;
    clr[40] = &#34;#ff4596&#34;
    clr[32] = &#34;#86ebc1&#34;
    return clr


def plot_qms_dir(dir=&#34;&#34;, ls=[], out=&#34;batch_qms_plot.pdf&#34;, **kws):
    &#34;&#34;&#34; Provided dir, reads all converted Quelee *.csv&#39;s and plots into a PDF

    Parameters
    ----------
    ls: list of absolute paths to files to plot
        OR
    dir: string
            directory to scan and plot
    out: string 
        output pdf file name or absolute path
    ext: string
        files extention, CSV by default
    figsize: float
        figure width, 500 by default
    anchor: list
        Matplotlib bbox_to_inches [1,1]
    rasterized: bool
        Matplotlib&#39;s rasterized option, when there are too many lines for a PDF
    ylim: list or tuple
           by default [1e-14,1e-5]        
    &#34;&#34;&#34;
    import os, matplotlib.pylab as plt, numpy as np
    from matplotlib.backends.backend_pdf import PdfPages
    import aklab.mpls as akmpl

    ext = kws.get(&#34;ext&#34;, &#34;CSV&#34;)
    if not len(ls):
        if not len(dir):
            raise ValueError(&#34;either dir or ls must be provided, now both are empty&#34;)
        ls = os.listdir(dir)
        ls = [i for i in ls if i.endswith(ext)]
        ls = sorted(ls)[::-1]

    figsize = kws.get(&#34;figsize&#34;, 500)
    anchor = kws.get(&#34;anhcor&#34;, [1, 1])
    rasterized = kws.get(&#34;rasterized&#34;, True)
    ylim = kws.get(&#34;ylim&#34;, [1e-14, 1e-5])
    with PdfPages(out) as pdf:
        for i in ls:
            plt.style.use(os.path.join(package_directory, &#34;notex.mplstyle&#34;))
            qms = QMS(i)
            qms.plot(
                rasterized=rasterized, ylim=ylim, colors=generate_colors(qms.masslist, cmap=plt.cm.twilight)
            )
            fig = plt.gcf()
            fig.set_size_inches(akmpl.set_size(figsize))
            axs = fig.get_axes()
            axs[0].legend(bbox_to_anchor=anchor)
            # TODO: derive ticks from ylim
            axs[0].set_yticks(np.logspace(-14, -5, 14 - 5 + 1))
            akmpl.set_tick_size(plt.gca(), *(1, 4, 0.5, 2))
            pdf.savefig(dpi=300)
            plt.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aklab.qulee.customgrid"><code class="name flex">
<span>def <span class="ident">customgrid</span></span>(<span>ax, **kws)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def customgrid(ax, **kws):
    # Setup grid
    gridalpha = kws.get(&#34;gridalpha&#34;, [0.1, 0.3])
    ax.grid(which=&#34;minor&#34;, linestyle=&#34;-&#34;, alpha=gridalpha[0])
    ax.grid(which=&#34;major&#34;, linestyle=&#34;-&#34;, alpha=gridalpha[1])</code></pre>
</details>
</dd>
<dt id="aklab.qulee.customticks"><code class="name flex">
<span>def <span class="ident">customticks</span></span>(<span>ax)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def customticks(ax):
    from matplotlib.ticker import LogLocator, AutoMinorLocator

    # Setup ticks
    xys = [ax.xaxis, ax.yaxis]
    [a.set_minor_locator(AutoMinorLocator()) for a in xys]
    ls = [7, 4]
    ws = [1, 0.8]
    [
        [a.set_tick_params(width=j, length=i, which=k) for i, j, k in zip(ls, ws, [&#34;major&#34;, &#34;minor&#34;])]
        for a in xys
    ]</code></pre>
</details>
</dd>
<dt id="aklab.qulee.generate_colors"><code class="name flex">
<span>def <span class="ident">generate_colors</span></span>(<span>masslist, **kws)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate colors based on masslist</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masslist</code></strong> :&ensp;<code>list</code></dt>
<dd>list of masses to be plotted</dd>
<dt><strong><code>cmap</code></strong> :&ensp;<code>matplotlib colormap for color cycle</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>clr</code></strong> :&ensp;<code>list</code></dt>
<dd>list of colors</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_colors(masslist, **kws):
    &#34;&#34;&#34; Generate colors based on masslist
    
    Parameters
    ----------
    masslist: list
            list of masses to be plotted
    cmap: matplotlib colormap for color cycle
    
    Returns
    -------
    clr: list
        list of colors
    &#34;&#34;&#34;
    import matplotlib.pylab as plt, numpy as np

    cmap = kws.get(&#34;cmap&#34;, plt.cm.twilight)

    color = cmap(np.linspace(0.1, 0.9, len(masslist)))
    clr = {i: j for i, j in zip(masslist, color)}
    clr[2] = &#34;#ff421c&#34;
    clr[3] = &#34;#ffa305&#34;
    clr[4] = &#34;#6fff1c&#34;
    clr[18] = &#34;#05ffde&#34;
    clr[28] = &#34;#5983ff&#34;
    clr[40] = &#34;#ff4596&#34;
    clr[32] = &#34;#86ebc1&#34;
    return clr</code></pre>
</details>
</dd>
<dt id="aklab.qulee.plot_qms_dir"><code class="name flex">
<span>def <span class="ident">plot_qms_dir</span></span>(<span>dir='', ls=[], out='batch_qms_plot.pdf', **kws)</span>
</code></dt>
<dd>
<div class="desc"><p>Provided dir, reads all converted Quelee *.csv's and plots into a PDF</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ls</code></strong> :&ensp;<code>list</code> of <code>absolute paths to files to plot</code></dt>
<dd>OR</dd>
<dt><strong><code>dir</code></strong> :&ensp;<code>string</code></dt>
<dd>directory to scan and plot</dd>
<dt><strong><code>out</code></strong> :&ensp;<code>string </code></dt>
<dd>output pdf file name or absolute path</dd>
<dt><strong><code>ext</code></strong> :&ensp;<code>string</code></dt>
<dd>files extention, CSV by default</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>float</code></dt>
<dd>figure width, 500 by default</dd>
<dt><strong><code>anchor</code></strong> :&ensp;<code>list</code></dt>
<dd>Matplotlib bbox_to_inches [1,1]</dd>
<dt><strong><code>rasterized</code></strong> :&ensp;<code>bool</code></dt>
<dd>Matplotlib's rasterized option, when there are too many lines for a PDF</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>by default [1e-14,1e-5]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_qms_dir(dir=&#34;&#34;, ls=[], out=&#34;batch_qms_plot.pdf&#34;, **kws):
    &#34;&#34;&#34; Provided dir, reads all converted Quelee *.csv&#39;s and plots into a PDF

    Parameters
    ----------
    ls: list of absolute paths to files to plot
        OR
    dir: string
            directory to scan and plot
    out: string 
        output pdf file name or absolute path
    ext: string
        files extention, CSV by default
    figsize: float
        figure width, 500 by default
    anchor: list
        Matplotlib bbox_to_inches [1,1]
    rasterized: bool
        Matplotlib&#39;s rasterized option, when there are too many lines for a PDF
    ylim: list or tuple
           by default [1e-14,1e-5]        
    &#34;&#34;&#34;
    import os, matplotlib.pylab as plt, numpy as np
    from matplotlib.backends.backend_pdf import PdfPages
    import aklab.mpls as akmpl

    ext = kws.get(&#34;ext&#34;, &#34;CSV&#34;)
    if not len(ls):
        if not len(dir):
            raise ValueError(&#34;either dir or ls must be provided, now both are empty&#34;)
        ls = os.listdir(dir)
        ls = [i for i in ls if i.endswith(ext)]
        ls = sorted(ls)[::-1]

    figsize = kws.get(&#34;figsize&#34;, 500)
    anchor = kws.get(&#34;anhcor&#34;, [1, 1])
    rasterized = kws.get(&#34;rasterized&#34;, True)
    ylim = kws.get(&#34;ylim&#34;, [1e-14, 1e-5])
    with PdfPages(out) as pdf:
        for i in ls:
            plt.style.use(os.path.join(package_directory, &#34;notex.mplstyle&#34;))
            qms = QMS(i)
            qms.plot(
                rasterized=rasterized, ylim=ylim, colors=generate_colors(qms.masslist, cmap=plt.cm.twilight)
            )
            fig = plt.gcf()
            fig.set_size_inches(akmpl.set_size(figsize))
            axs = fig.get_axes()
            axs[0].legend(bbox_to_anchor=anchor)
            # TODO: derive ticks from ylim
            axs[0].set_yticks(np.logspace(-14, -5, 14 - 5 + 1))
            akmpl.set_tick_size(plt.gca(), *(1, 4, 0.5, 2))
            pdf.savefig(dpi=300)
            plt.close()</code></pre>
</details>
</dd>
<dt id="aklab.qulee.t2s"><code class="name flex">
<span>def <span class="ident">t2s</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts QMS timing into seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def t2s(t):
    &#34;&#34;&#34;
    Converts QMS timing into seconds.
    &#34;&#34;&#34;
    import datetime, time

    ms = t.split(&#34;.&#34;)[1]
    hh = int(t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[0])
    mm = t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[1]
    ss = t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[2]
    hoffset = 0
    if int(t.split(&#34;.&#34;)[0].split(&#34;:&#34;)[0]) &gt; 23:
        hoffset = hh // 24
        tt = &#34;0%d:%s:%s&#34; % (hh - hoffset * 24, mm, ss)
    else:
        tt = &#34;0%d:%s:%s&#34; % (hh, mm, ss)
    x = time.strptime(tt, &#34;0%H:%M:%S&#34;)
    return (
        datetime.timedelta(hours=hoffset * 24 + x.tm_hour, minutes=x.tm_min, seconds=x.tm_sec).total_seconds()
        + float(ms) * 1e-3
    )</code></pre>
</details>
</dd>
<dt id="aklab.qulee.t2sa"><code class="name flex">
<span>def <span class="ident">t2sa</span></span>(<span>ta)</span>
</code></dt>
<dd>
<div class="desc"><p>convert an array of strings of the Qulee format: '000:00:00.625' to time in seconds.
'000:00:00.625' -&gt; 'hhh:mm:ss.ms'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def t2sa(ta):
    &#34;&#34;&#34;
    convert an array of strings of the Qulee format: &#39;000:00:00.625&#39; to time in seconds.
    &#39;000:00:00.625&#39; -&gt; &#39;hhh:mm:ss.ms&#39;
    &#34;&#34;&#34;
    import numpy as np

    return np.array([t2s(tt) for tt in ta])</code></pre>
</details>
</dd>
<dt id="aklab.qulee.tocsv"><code class="name flex">
<span>def <span class="ident">tocsv</span></span>(<span>filename, **kws)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert native binary into csv with Quelee software installed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tocsv(filename, **kws):
    &#34;&#34;&#34; Convert native binary into csv with Quelee software installed.
    &#34;&#34;&#34;
    import platform, sys, subprocess, os, time

    if not platform.system() == &#34;Darwin&#34;:
        import win32api, win32con, win32com.client  # mouse control

        shell = win32com.client.Dispatch(&#34;WScript.Shell&#34;)  # this is to make a kay press

    try:
        retcode = subprocess.call(&#34;start &#34; + filename, shell=True)
        if retcode &lt; 0:
            print(&#34;Child was terminated by signal&#34;, retcode, file=sys.stderr)
        else:
            print(&#34;Child returned&#34;, file=sys.stderr)
    except OSError as e:
        print(&#34;Execution failed:&#34;, e, file=sys.stderr)

    &#34;&#34;&#34;Convert data to *.csv using this macro&#34;&#34;&#34;
    size = os.stat(os.path.join(filename)).st_size
    if size / 1.8e6 &lt; 1:
        tsave = 1
    else:
        tsave = int(size / 2e6) + 1
    &#34;&#34;&#34; windows script to convert *.qst to *.csv&#34;&#34;&#34;
    tt = 0.2
    time.sleep(tt)
    shell.SendKeys(&#34;{ESC}&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ENTER}&#34;)
    time.sleep(tt + 1)
    shell.SendKeys(&#34;%ft&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ENTER}&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;y&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ESC}&#34;)
    time.sleep(tt + tsave)
    shell.SendKeys(&#34;%fc&#34;)
    time.sleep(tt)
    shell.SendKeys(&#34;{ESC}&#34;)
    &#34;&#34;&#34; close Qulee&#34;&#34;&#34;
    shell.SendKeys(&#34;%{F4}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="aklab.qulee.QMS"><code class="flex name class">
<span>class <span class="ident">QMS</span></span>
<span>(</span><span>datapath)</span>
</code></dt>
<dd>
<div class="desc"><p>Read Qulee QMS CSV file, generate pandas.DataFrame, plot data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datapath</code></strong> :&ensp;<code>string</code></dt>
<dd>path to converted to <code>csv</code> format Qulee QMS data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QMS:
    &#34;&#34;&#34;Read Qulee QMS CSV file, generate pandas.DataFrame, plot data.
    
    Parameters
    ----------
    datapath: string
            path to converted to `csv` format Qulee QMS data.
    &#34;&#34;&#34;

    def __init__(self, datapath):
        &#34;&#34;&#34; &#34;&#34;&#34;
        self.data = None
        self.path = datapath
        self.qms_file_parser()
        self.load_data()
        self.generate_colors()

    def qms_file_parser(self):
        &#34;&#34;&#34; &#34; Given filepath to ULVAC&#39;s Qulee BGM QMS file, converted to *.csv,
        Parses the header, extracts column names, QMS settings, and line number where data starts
        &#34;&#34;&#34;
        import codecs
        import datetime

        channels = []
        mlist = []
        params = dict([])
        with codecs.open(self.path, &#34;r&#34;, &#34;shift_jisx0213&#34;) as f:
            for index, line in enumerate(f):
                string = line.strip()
                # get masslist
                if string.startswith(&#39;&#34;測定質量数 &#39;):
                    masslist = string.split(&#39;&#34;&#39;)[2].split(&#34;,&#34;)
                    mlist = []
                    for m in masslist:
                        if m != &#34;&#34; and m != &#34;--&#34;:
                            mlist.append(int(m))
                if string.startswith(&#39;&#34;測定スピード&#39;):
                    channels.append(string)
                if string.startswith(&#39;&#34;SEM 電圧&#39;):
                    params[&#34;sem&#34;] = string.split(&#34;,&#34;)[1]

                if string.startswith(&#39;&#34;選択 FIL&#39;):
                    params[&#34;filament&#34;] = string.split(&#34;,&#34;)[1][1:-1].strip()
                if string.startswith(&#39;&#34;選択 SEM / FC&#39;):
                    params[&#34;semfil&#34;] = string.split(&#34;,&#34;)[1][1:-1].strip()
                if string.startswith(&#39;&#34;測定開始日時 &#39;):
                    params[&#34;start&#34;] = string.split(&#34;,&#34;)[1].strip()
                    self.start = datetime.datetime.strptime(params[&#34;start&#34;], &#34;%Y/%m/%d %H:%M:%S&#34;)
                if string.startswith(&#39;&#34;測定終了日時 &#39;):
                    params[&#34;end&#34;] = string.split(&#34;,&#34;)[1].strip()
                    self.end = datetime.datetime.strptime(params[&#34;end&#34;], &#34;%Y/%m/%d %H:%M:%S&#34;)
                if string.startswith(&#39;&#34;レシピ名称  &#39;):
                    try:
                        params[&#34;recipe&#34;] = str(string.split(&#34;,&#34;)[1][1:-1]).strip()
                    except NameError:
                        params[&#34;recipe&#34;] = str(string.split(&#34;,&#34;)[1][1:-1]).strip()
                if string.startswith(&#39;&#34;イオン化電圧 &#39;):
                    params[&#34;ionization&#34;] = string.split(&#34;,&#34;)[1].strip()
                if string.startswith(&#39;&#34;測定スピード   &#39;):
                    params[&#34;mass_sampling&#34;] = string.split(&#34;,&#34;)[1].strip()

                if string.startswith(&#34;1&#34;):
                    break
            chName = [&#34;No&#34;, &#34;Time&#34;, &#34;Trigger&#34;, &#34;analog2&#34;, &#34;qmsTP&#34;]
            for m in mlist:
                chName.append(&#34;m%d&#34; % m)

            self.colnames = chName
            self.skiprows = index
            self.stats = params
            self.masslist = [int(i[1:]) for i in self.colnames if i.startswith(&#34;m&#34;)]

    def load_data(self):
        &#34;&#34;&#34;Generates DataFrame from qms data with proper datetime column for time
        &#34;&#34;&#34;
        import pandas as pd
        from pandas import read_csv

        qmsdata = read_csv(
            self.path,
            skiprows=self.skiprows,
            delimiter=&#34;,&#34;,
            names=self.colnames,
            usecols=self.colnames,
            na_values=[&#34;-------&#34;, &#34;-&#34;],
            encoding=&#34;shift_jisx0213&#34;,
        )

        qmsdata.insert(0, &#34;tsec&#34;, t2sa(qmsdata[&#34;Time&#34;].values))
        timesec = pd.to_timedelta(qmsdata[&#34;tsec&#34;], unit=&#34;s&#34;) + self.start
        qmsdata.insert(0, &#34;date&#34;, timesec)

        self.data = qmsdata

    def generate_colors(self):
        &#34;&#34;&#34; Generate colors based on masslist&#34;&#34;&#34;
        import matplotlib.pylab as plt
        import numpy as np

        color = plt.cm.hsv(np.linspace(0.1, 0.9, len(self.masslist)))
        clr = {i: j for i, j in zip(self.masslist, color)}
        clr[2] = &#34;#ff421c&#34;
        clr[3] = &#34;#ffa305&#34;
        clr[4] = &#34;#6fff1c&#34;
        self.clr = clr

    def slice(self, delta):
        &#34;&#34;&#34; Slice DataFrame by datetime interval

        Parameters
        ----------
        delta: list
            list of datetime.dateme objects for the start and the end of an interval

        Returns
        -------
        data: pandas.DataFrame
            sliced qms dataframe
        &#34;&#34;&#34;
        a = delta[0].strftime(&#34;%Y%m%d%H%M%S&#34;)
        b = delta[1].strftime(&#34;%Y%m%d%H%M%S&#34;)
        return self.data.query(f&#34;{a} &lt; date &lt; {b}&#34;)

    def plot(self, **kws):
        &#34;&#34;&#34;plot time traces
        
        Parameters
        ----------
        masslist: list
            Specify list of masses to plot. Plots all by default.
        fro: datetime
            starting time, self.start by default.
        to: datetime
            ending time, self.end by default
        ylim: list or tuple 
            axis ylims
        gridalpha: float
             transparancy of the grid lines
        figsize: tuple
            figure size, (8,6) by default
        rasterized: bool
            rasterized option for matplotlib
        colors: list
            list of colors for color cycle
        bbox_to_anchor: list or tuple
            bbox_to_anchor argument for matplotlib legend
        &#34;&#34;&#34;
        import matplotlib.pylab as plt
        from matplotlib.ticker import AutoMinorLocator

        fro = kws.get(&#34;fro&#34;, self.start)
        tto = kws.get(&#34;tto&#34;, self.end)

        a = fro.strftime(&#34;%Y%m%d%H%M%S&#34;)
        b = tto.strftime(&#34;%Y%m%d%H%M%S&#34;)
        df = self.data.query(f&#34;{a} &lt; date &lt; {b}&#34;)

        figsize = kws.get(&#34;figsize&#34;, (8, 6))

        fig = plt.figure(figsize=figsize, facecolor=&#34;w&#34;)
        ax = plt.gca()

        masslist = kws.get(&#34;masslist&#34;, self.masslist)
        rasterized = kws.get(&#34;rasterized&#34;, False)
        clrs = kws.get(&#34;colors&#34;, self.clr)

        [plt.plot(df[&#34;date&#34;], df[f&#34;m{i}&#34;], label=f&#34;m{i}&#34;, rasterized=rasterized, c=clrs[i]) for i in masslist]

        ax.set_xlabel(&#34;time&#34;)
        ax.set_ylabel(&#34;QMS Current, A&#34;)
        plt.xticks(rotation=25, ha=&#34;right&#34;)
        ylims = kws.get(&#34;ylim&#34;, False)
        if ylims:
            ax.set_ylim(ylims)

        txt = (
            f&#34;{self.stats[&#39;start&#39;].split()[0]} {self.stats[&#39;filament&#39;]} {self.stats[&#39;semfil&#39;]} &#34;
            + f&#34;{self.stats[&#39;sem&#39;]} {self.stats[&#39;recipe&#39;]} {self.stats[&#39;mass_sampling&#39;]} s/a.m.e&#34;
        )
        ax.text(-0.15, 1.05, txt, transform=ax.transAxes)

        gridalpha = kws.get(&#34;gridalpha&#34;, [0.1, 0.3])
        customgrid(ax, gridalpha=gridalpha)
        customticks(ax)
        ax.set_yscale(&#34;log&#34;)

        axt = ax.twinx()
        trigger = self.data[&#34;Trigger&#34;].values
        axt.plot(df[&#34;date&#34;], df[&#34;Trigger&#34;] / df[&#34;Trigger&#34;].max(), &#34;r&#34;)
        axt.set_ylim(0, 20)
        axt.axes.yaxis.set_ticks([])

        bbox_to_anchor = kws.get(&#34;bbox_to_anchor&#34;, [1, 1])
        ax.legend(loc=1, bbox_to_anchor=bbox_to_anchor)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="aklab.qulee.QMS.generate_colors"><code class="name flex">
<span>def <span class="ident">generate_colors</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate colors based on masslist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_colors(self):
    &#34;&#34;&#34; Generate colors based on masslist&#34;&#34;&#34;
    import matplotlib.pylab as plt
    import numpy as np

    color = plt.cm.hsv(np.linspace(0.1, 0.9, len(self.masslist)))
    clr = {i: j for i, j in zip(self.masslist, color)}
    clr[2] = &#34;#ff421c&#34;
    clr[3] = &#34;#ffa305&#34;
    clr[4] = &#34;#6fff1c&#34;
    self.clr = clr</code></pre>
</details>
</dd>
<dt id="aklab.qulee.QMS.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates DataFrame from qms data with proper datetime column for time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_data(self):
    &#34;&#34;&#34;Generates DataFrame from qms data with proper datetime column for time
    &#34;&#34;&#34;
    import pandas as pd
    from pandas import read_csv

    qmsdata = read_csv(
        self.path,
        skiprows=self.skiprows,
        delimiter=&#34;,&#34;,
        names=self.colnames,
        usecols=self.colnames,
        na_values=[&#34;-------&#34;, &#34;-&#34;],
        encoding=&#34;shift_jisx0213&#34;,
    )

    qmsdata.insert(0, &#34;tsec&#34;, t2sa(qmsdata[&#34;Time&#34;].values))
    timesec = pd.to_timedelta(qmsdata[&#34;tsec&#34;], unit=&#34;s&#34;) + self.start
    qmsdata.insert(0, &#34;date&#34;, timesec)

    self.data = qmsdata</code></pre>
</details>
</dd>
<dt id="aklab.qulee.QMS.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, **kws)</span>
</code></dt>
<dd>
<div class="desc"><p>plot time traces</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>masslist</code></strong> :&ensp;<code>list</code></dt>
<dd>Specify list of masses to plot. Plots all by default.</dd>
<dt><strong><code>fro</code></strong> :&ensp;<code>datetime</code></dt>
<dd>starting time, self.start by default.</dd>
<dt><strong><code>to</code></strong> :&ensp;<code>datetime</code></dt>
<dd>ending time, self.end by default</dd>
<dt><strong><code>ylim</code></strong> :&ensp;<code>list</code> or <code>tuple </code></dt>
<dd>axis ylims</dd>
<dt><strong><code>gridalpha</code></strong> :&ensp;<code>float</code></dt>
<dd>transparancy of the grid lines</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>tuple</code></dt>
<dd>figure size, (8,6) by default</dd>
<dt><strong><code>rasterized</code></strong> :&ensp;<code>bool</code></dt>
<dd>rasterized option for matplotlib</dd>
<dt><strong><code>colors</code></strong> :&ensp;<code>list</code></dt>
<dd>list of colors for color cycle</dd>
<dt><strong><code>bbox_to_anchor</code></strong> :&ensp;<code>list</code> or <code>tuple</code></dt>
<dd>bbox_to_anchor argument for matplotlib legend</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self, **kws):
    &#34;&#34;&#34;plot time traces
    
    Parameters
    ----------
    masslist: list
        Specify list of masses to plot. Plots all by default.
    fro: datetime
        starting time, self.start by default.
    to: datetime
        ending time, self.end by default
    ylim: list or tuple 
        axis ylims
    gridalpha: float
         transparancy of the grid lines
    figsize: tuple
        figure size, (8,6) by default
    rasterized: bool
        rasterized option for matplotlib
    colors: list
        list of colors for color cycle
    bbox_to_anchor: list or tuple
        bbox_to_anchor argument for matplotlib legend
    &#34;&#34;&#34;
    import matplotlib.pylab as plt
    from matplotlib.ticker import AutoMinorLocator

    fro = kws.get(&#34;fro&#34;, self.start)
    tto = kws.get(&#34;tto&#34;, self.end)

    a = fro.strftime(&#34;%Y%m%d%H%M%S&#34;)
    b = tto.strftime(&#34;%Y%m%d%H%M%S&#34;)
    df = self.data.query(f&#34;{a} &lt; date &lt; {b}&#34;)

    figsize = kws.get(&#34;figsize&#34;, (8, 6))

    fig = plt.figure(figsize=figsize, facecolor=&#34;w&#34;)
    ax = plt.gca()

    masslist = kws.get(&#34;masslist&#34;, self.masslist)
    rasterized = kws.get(&#34;rasterized&#34;, False)
    clrs = kws.get(&#34;colors&#34;, self.clr)

    [plt.plot(df[&#34;date&#34;], df[f&#34;m{i}&#34;], label=f&#34;m{i}&#34;, rasterized=rasterized, c=clrs[i]) for i in masslist]

    ax.set_xlabel(&#34;time&#34;)
    ax.set_ylabel(&#34;QMS Current, A&#34;)
    plt.xticks(rotation=25, ha=&#34;right&#34;)
    ylims = kws.get(&#34;ylim&#34;, False)
    if ylims:
        ax.set_ylim(ylims)

    txt = (
        f&#34;{self.stats[&#39;start&#39;].split()[0]} {self.stats[&#39;filament&#39;]} {self.stats[&#39;semfil&#39;]} &#34;
        + f&#34;{self.stats[&#39;sem&#39;]} {self.stats[&#39;recipe&#39;]} {self.stats[&#39;mass_sampling&#39;]} s/a.m.e&#34;
    )
    ax.text(-0.15, 1.05, txt, transform=ax.transAxes)

    gridalpha = kws.get(&#34;gridalpha&#34;, [0.1, 0.3])
    customgrid(ax, gridalpha=gridalpha)
    customticks(ax)
    ax.set_yscale(&#34;log&#34;)

    axt = ax.twinx()
    trigger = self.data[&#34;Trigger&#34;].values
    axt.plot(df[&#34;date&#34;], df[&#34;Trigger&#34;] / df[&#34;Trigger&#34;].max(), &#34;r&#34;)
    axt.set_ylim(0, 20)
    axt.axes.yaxis.set_ticks([])

    bbox_to_anchor = kws.get(&#34;bbox_to_anchor&#34;, [1, 1])
    ax.legend(loc=1, bbox_to_anchor=bbox_to_anchor)</code></pre>
</details>
</dd>
<dt id="aklab.qulee.QMS.qms_file_parser"><code class="name flex">
<span>def <span class="ident">qms_file_parser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>" Given filepath to ULVAC's Qulee BGM QMS file, converted to *.csv,
Parses the header, extracts column names, QMS settings, and line number where data starts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qms_file_parser(self):
    &#34;&#34;&#34; &#34; Given filepath to ULVAC&#39;s Qulee BGM QMS file, converted to *.csv,
    Parses the header, extracts column names, QMS settings, and line number where data starts
    &#34;&#34;&#34;
    import codecs
    import datetime

    channels = []
    mlist = []
    params = dict([])
    with codecs.open(self.path, &#34;r&#34;, &#34;shift_jisx0213&#34;) as f:
        for index, line in enumerate(f):
            string = line.strip()
            # get masslist
            if string.startswith(&#39;&#34;測定質量数 &#39;):
                masslist = string.split(&#39;&#34;&#39;)[2].split(&#34;,&#34;)
                mlist = []
                for m in masslist:
                    if m != &#34;&#34; and m != &#34;--&#34;:
                        mlist.append(int(m))
            if string.startswith(&#39;&#34;測定スピード&#39;):
                channels.append(string)
            if string.startswith(&#39;&#34;SEM 電圧&#39;):
                params[&#34;sem&#34;] = string.split(&#34;,&#34;)[1]

            if string.startswith(&#39;&#34;選択 FIL&#39;):
                params[&#34;filament&#34;] = string.split(&#34;,&#34;)[1][1:-1].strip()
            if string.startswith(&#39;&#34;選択 SEM / FC&#39;):
                params[&#34;semfil&#34;] = string.split(&#34;,&#34;)[1][1:-1].strip()
            if string.startswith(&#39;&#34;測定開始日時 &#39;):
                params[&#34;start&#34;] = string.split(&#34;,&#34;)[1].strip()
                self.start = datetime.datetime.strptime(params[&#34;start&#34;], &#34;%Y/%m/%d %H:%M:%S&#34;)
            if string.startswith(&#39;&#34;測定終了日時 &#39;):
                params[&#34;end&#34;] = string.split(&#34;,&#34;)[1].strip()
                self.end = datetime.datetime.strptime(params[&#34;end&#34;], &#34;%Y/%m/%d %H:%M:%S&#34;)
            if string.startswith(&#39;&#34;レシピ名称  &#39;):
                try:
                    params[&#34;recipe&#34;] = str(string.split(&#34;,&#34;)[1][1:-1]).strip()
                except NameError:
                    params[&#34;recipe&#34;] = str(string.split(&#34;,&#34;)[1][1:-1]).strip()
            if string.startswith(&#39;&#34;イオン化電圧 &#39;):
                params[&#34;ionization&#34;] = string.split(&#34;,&#34;)[1].strip()
            if string.startswith(&#39;&#34;測定スピード   &#39;):
                params[&#34;mass_sampling&#34;] = string.split(&#34;,&#34;)[1].strip()

            if string.startswith(&#34;1&#34;):
                break
        chName = [&#34;No&#34;, &#34;Time&#34;, &#34;Trigger&#34;, &#34;analog2&#34;, &#34;qmsTP&#34;]
        for m in mlist:
            chName.append(&#34;m%d&#34; % m)

        self.colnames = chName
        self.skiprows = index
        self.stats = params
        self.masslist = [int(i[1:]) for i in self.colnames if i.startswith(&#34;m&#34;)]</code></pre>
</details>
</dd>
<dt id="aklab.qulee.QMS.slice"><code class="name flex">
<span>def <span class="ident">slice</span></span>(<span>self, delta)</span>
</code></dt>
<dd>
<div class="desc"><p>Slice DataFrame by datetime interval</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>delta</code></strong> :&ensp;<code>list</code></dt>
<dd>list of datetime.dateme objects for the start and the end of an interval</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>sliced qms dataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def slice(self, delta):
    &#34;&#34;&#34; Slice DataFrame by datetime interval

    Parameters
    ----------
    delta: list
        list of datetime.dateme objects for the start and the end of an interval

    Returns
    -------
    data: pandas.DataFrame
        sliced qms dataframe
    &#34;&#34;&#34;
    a = delta[0].strftime(&#34;%Y%m%d%H%M%S&#34;)
    b = delta[1].strftime(&#34;%Y%m%d%H%M%S&#34;)
    return self.data.query(f&#34;{a} &lt; date &lt; {b}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aklab" href="index.html">aklab</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="aklab.qulee.customgrid" href="#aklab.qulee.customgrid">customgrid</a></code></li>
<li><code><a title="aklab.qulee.customticks" href="#aklab.qulee.customticks">customticks</a></code></li>
<li><code><a title="aklab.qulee.generate_colors" href="#aklab.qulee.generate_colors">generate_colors</a></code></li>
<li><code><a title="aklab.qulee.plot_qms_dir" href="#aklab.qulee.plot_qms_dir">plot_qms_dir</a></code></li>
<li><code><a title="aklab.qulee.t2s" href="#aklab.qulee.t2s">t2s</a></code></li>
<li><code><a title="aklab.qulee.t2sa" href="#aklab.qulee.t2sa">t2sa</a></code></li>
<li><code><a title="aklab.qulee.tocsv" href="#aklab.qulee.tocsv">tocsv</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="aklab.qulee.QMS" href="#aklab.qulee.QMS">QMS</a></code></h4>
<ul class="">
<li><code><a title="aklab.qulee.QMS.generate_colors" href="#aklab.qulee.QMS.generate_colors">generate_colors</a></code></li>
<li><code><a title="aklab.qulee.QMS.load_data" href="#aklab.qulee.QMS.load_data">load_data</a></code></li>
<li><code><a title="aklab.qulee.QMS.plot" href="#aklab.qulee.QMS.plot">plot</a></code></li>
<li><code><a title="aklab.qulee.QMS.qms_file_parser" href="#aklab.qulee.QMS.qms_file_parser">qms_file_parser</a></code></li>
<li><code><a title="aklab.qulee.QMS.slice" href="#aklab.qulee.QMS.slice">slice</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>